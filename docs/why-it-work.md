# なぜ動くのか？ (Why it Works)

このドキュメントは、`misskey-antennatl` アプリケーションがどのようにして技術的に機能しているかを解説します。

## 1. 全体アーキテクチャ

このアプリケーションは、**Next.js (App Router)** をフレームワークとして採用したシングルページアプリケーション (SPA) です。
主要な構成要素は以下の通りです。

- **フロントエンド**: React (Next.js) + Tailwind CSS
  - ユーザーインターフェースの描画と状態管理を担当します。
  - `useSWR` を用いて、バックエンドAPIから非同期にデータを取得し、30秒ごとに自動更新します。

- **バックエンド (API Route)**: Next.js Edge Runtime
  - `/api/mentionContext` という単一のエンドポイントを提供します。
  - VercelのEdge Runtime上で動作し、Misskey APIへのリクエストを中継・加工することで、クライアントへのレスポンスを高速化します。

- **外部API**: Misskey API
  - アンテナのノート取得や、会話スレッドの取得など、すべてのデータソースはこのAPIに依存します。

## 2. データフロー

ユーザーがページにアクセスしてからタイムラインが表示されるまでのデータの流れは以下の通りです。

1.  **クライアント → Next.js API Route**
    - ブラウザ（クライアント）の `HomePage` コンポーネントがマウントされると、`useSWR` フックが `/api/mentionContext` に対してGETリクエストを送信します。

2.  **Next.js API Route → Misskey API**
    - `/api/mentionContext` (Edge Runtime) はリクエストを受け取ると、サーバーサイドに保存された環境変数 (`.env.local`) を使用してMisskey APIにアクセスします。
    - まず、`antennas/notes` エンドポイントを叩き、メンションが含まれるノートの一覧を取得します。
    - 次に、取得した各ノートIDを元に `notes/conversation` エンドポイントを並列で叩き（`p-map`で同時実行数を制限）、それぞれの会話スreadを取得します。

3.  **Next.js API Route → クライアント**
    - APIルートは、Misskeyから取得したデータを `Thread` という一貫したデータ構造に整形・検証（Zodを使用）した後、JSON形式でクライアントに返却します。
    - この際、`Cache-Control` ヘッダーを付与し、VercelのCDNに60秒間キャッシュさせることで、API負荷を軽減します。

4.  **UIの更新**
    - クライアントはSWR経由でJSONデータを受け取ると、Reactコンポーネント (`Thread`, `NoteCard`) を使ってUIを再描画し、ユーザーにタイムラインを表示します。

## 3. 主要な技術選択

- **Next.js App Router**: モダンなReactの機能（Server Components等）を活用しつつ、ファイルベースのルーティングで直感的な開発を可能にするために採用しました。
- **Edge Runtime**: APIリクエストの地理的な遅延を最小化し、高速な応答を実現するために選択しました。Node.jsのすべての機能は使えませんが、`fetch`を中心とした処理には最適です。
- **SWR**: データ取得におけるキャッシュ管理、自動再検証、ローディング・エラー状態のハンドリングを宣言的に記述できるため、UI開発の複雑さを大幅に削減します。
- **Zod**: 外部API（Misskey API）からのレスポンスをランタイムで検証し、アプリケーション全体で型安全性を保証するために不可欠です。
- **Tailwind CSS**: ユーティリティファーストのアプローチにより、CSSを直接書くことなく、迅速かつ一貫性のあるUIデザインを構築できます。

## 4. 絵文字処理の仕組み

このアプリケーションでは、Misskeyのカスタム絵文字をノート本文中に表示するために、独自の絵文字処理ロジックを実装しています。

### 4.1. 絵文字データの取得とキャッシュ (`src/lib/emoji.ts`)

- **`fetchAndCacheEmojis` 関数**:
    - アプリケーション起動時（`src/app/page.tsx` の `useEffect` フック内）に一度だけ呼び出されます。
    - Misskeyインスタンスの `/api/emojis` エンドポイントに対して **POST** メソッドでリクエストを送信し、利用可能なすべてのカスタム絵文字のリストを取得します。
    - 取得した絵文字データ（絵文字名とURL）は、`LRUCache` インスタンスである `emojiCache` に保存されます。
    - **LRUCache**: キャッシュの最大サイズ (`max`) を指定できるキャッシュ機構です。今回のトラブルシューティングでは、初期設定の `max: 500` では取得する絵文字数（約977個）に対して不足しており、古い絵文字がキャッシュから削除されてしまう問題が発生しました。これを `max: 2000` に増やすことで解決しました。

### 4.2. ノート本文中の絵文字置換 (`src/lib/emoji.ts`)

- **`parseNoteText` 関数**:
    - ノートのテキストとMisskeyインスタンスのホスト名を受け取ります。
    - 正規表現 `/:( [a-zA-Z0-9_\-]+):/g` を使用して、テキスト内の `:emoji_name:` 形式のショートコードをすべて検索します。
    - 検索された絵文字名が `emojiCache` に存在する場合、その絵文字のURLを使用して `<img>` タグを生成し、元のショートコードと置換します。
    - `class="inline-block h-5 w-5"` を付与することで、Tailwind CSSによって絵文字画像がインラインで表示され、適切なサイズに調整されます。

## 5. レンダリングとハイドレーション

Next.jsのApp Routerでは、デフォルトでReact Server Components (RSC) が使用され、サーバーサイドでコンポーネントがレンダリングされます。しかし、クライアントサイドでのインタラクティブな動作が必要な場合は、`"use client"` ディレクティブを使用します。

- **`"use client"` ディレクティブ**:
    - `src/app/page.tsx` や `src/components/NoteCard.tsx` の冒頭に記述されており、これらのコンポーネントがクライアントサイドでレンダリングされることを示します。これにより、`useState` や `useEffect` といったReact Hooksや、ブラウザAPI（`fetch`など）を使用できるようになります。

- **ハイドレーションエラーとその解決**:
    - **問題**: サーバーサイドでレンダリングされたHTMLと、クライアントサイドでJavaScriptが実行された後に生成されるHTMLが一致しない場合に発生するエラーです。今回のケースでは、サーバーサイドでは絵文字キャッシュがまだ存在しないため、絵文字ショートコードがそのままHTMLに出力されます。しかし、クライアントサイドでは非同期で絵文字キャッシュが読み込まれた後に絵文字画像に置換されるため、初期レンダリング時に不一致が生じていました。
    - **解決策**: `src/app/page.tsx` に `isEmojiCacheReady` という状態を導入しました。`fetchAndCacheEmojis` が完了し、絵文字キャッシュが準備できるまで、ノートの描画を遅延させることで、サーバーとクライアントのHTMLの不一致を防ぎ、ハイドレーションエラーを解消しました。

- **`dangerouslySetInnerHTML` の使用**:
    - `src/components/NoteCard.tsx` では、`parseNoteText` 関数によって生成されたHTML文字列を直接DOMに挿入するために `dangerouslySetInnerHTML` を使用しています。
    - **注意点**: このプロパティは、XSS（クロスサイトスクリプティング）攻撃のリスクがあるため、信頼できるソースからのHTML文字列にのみ使用すべきです。本アプリケーションでは、Misskey APIから取得したノート本文を処理しており、絵文字置換以外のユーザー入力によるHTML挿入は行わないため、安全に使用しています。