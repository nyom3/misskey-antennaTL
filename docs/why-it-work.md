# なぜ動くのか？ (Why it Works)

このドキュメントは、`misskey-antennatl` アプリケーションがどのようにして技術的に機能しているかを解説します。

## 1. 全体アーキテクチャ

このアプリケーションは、**Next.js (App Router)** をフレームワークとして採用したシングルページアプリケーション (SPA) です。
主要な構成要素は以下の通りです。

- **フロントエンド**: React (Next.js) + Tailwind CSS
  - ユーザーインターフェースの描画と状態管理を担当します。
  - `useSWR` を用いて、バックエンドAPIから非同期にデータを取得し、30秒ごとに自動更新します。

- **バックエンド (API Route)**: Next.js Edge Runtime
  - `/api/mentionContext` という単一のエンドポイントを提供します。
  - VercelのEdge Runtime上で動作し、Misskey APIへのリクエストを中継・加工することで、クライアントへのレスポンスを高速化します。

- **外部API**: Misskey API
  - アンテナのノート取得や、会話スレッドの取得など、すべてのデータソースはこのAPIに依存します。

## 2. データフロー

ユーザーがページにアクセスしてからタイムラインが表示されるまでのデータの流れは以下の通りです。

1.  **クライアント → Next.js API Route**
    - ブラウザ（クライアント）の `HomePage` コンポーネントがマウントされると、`useSWR` フックが `/api/mentionContext` に対してGETリクエストを送信します。

2.  **Next.js API Route → Misskey API**
    - `/api/mentionContext` (Edge Runtime) はリクエストを受け取ると、サーバーサイドに保存された環境変数 (`.env.local`) を使用してMisskey APIにアクセスします。
    - まず、`antennas/notes` エンドポイントを叩き、メンションが含まれるノートの一覧を取得します。
    - 次に、取得した各ノートIDを元に `notes/conversation` エンドポイントを並列で叩き（`p-map`で同時実行数を制限）、それぞれの会話スreadを取得します。

3.  **Next.js API Route → クライアント**
    - APIルートは、Misskeyから取得したデータを `Thread` という一貫したデータ構造に整形・検証（Zodを使用）した後、JSON形式でクライアントに返却します。
    - この際、`Cache-Control` ヘッダーを付与し、VercelのCDNに60秒間キャッシュさせることで、API負荷を軽減します。

4.  **UIの更新**
    - クライアントはSWR経由でJSONデータを受け取ると、Reactコンポーネント (`Thread`, `NoteCard`) を使ってUIを再描画し、ユーザーにタイムラインを表示します。

## 3. 主要な技術選択

- **Next.js App Router**: モダンなReactの機能（Server Components等）を活用しつつ、ファイルベースのルーティングで直感的な開発を可能にするために採用しました。
- **Edge Runtime**: APIリクエストの地理的な遅延を最小化し、高速な応答を実現するために選択しました。Node.jsのすべての機能は使えませんが、`fetch`を中心とした処理には最適です。
- **SWR**: データ取得におけるキャッシュ管理、自動再検証、ローディング・エラー状態のハンドリングを宣言的に記述できるため、UI開発の複雑さを大幅に削減します。
- **Zod**: 外部API（Misskey API）からのレスポンスをランタイムで検証し、アプリケーション全体で型安全性を保証するために不可欠です。
- **Tailwind CSS**: ユーティリティファーストのアプローチにより、CSSを直接書くことなく、迅速かつ一貫性のあるUIデザインを構築できます。
